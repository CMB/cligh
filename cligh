#!/usr/bin/python
"""Simple command-line interface to github."""
# See the file LICENSE for copyright and license info.
import argparse
import re
import subprocess
import sys
import github2.client

PROGNAME = 'cligh'

# Helper functions.

def print_usage(message):
	"""Terminate, displaying a help message."""
	sys.stderr.write('Usage: %s  %s' % ( PROGNAME, message))
	sys.exit(1)

def print_error(message):
	"""Display an error message."""
	sys.stderr.write(message)

def die(message):
	"""Terminate, displaying an error message."""
	print_error(message)
	sys.exit(1)

def read_git_config(key):
	"""Read a value from git's configuration files."""
	cmd = ['git', 'config']
	cmd.append(key)
	output = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()
	return output[0].strip()

def get_username_and_token():
	"""Get the github username and API token."""
	username = read_git_config('github.user')
	if not username:
		die("""Error: unable to determine your github username.
Please make sure that it is included in the configuration file ~/.gitconfig.
""")

	token = read_git_config('github.token')
	if not token:
		die("""Error: unable to determine your github API token.
Please make sure that it is included in the configuration file ~/.gitconfig.
""")
	return (username, token)

def read_user_input(prompt, validator_func):
	"""Read and validate user input."""
	user_text = ''
	valid_input = False
	while not valid_input:
		sys.stdout.write('%s: ' % prompt)
		sys.stdout.flush()
		user_text = sys.stdin.readline()
		if not user_text:
			die('Could not read input from the user; unable to proceed.')
		user_text = user_text[0:-1] # Snip off the newline.
		if validator_func(user_text):
			valid_input = True
	return user_text

def get_repository_name(name):
	"""Get the name of the repository to work on.
Either we return the "name" argument (if it is a non-empty string), or
we try to detect the repository's name by looking at remote.origin.url."""

	if not name:
		name = read_git_config('remote.origin.url')
		match = re.match(r'git@github.com:(.*)\.git$', name)
		if not match:
			die(
"""This command expects a repository name, but the name is unknown.
There are two ways to indicate a repository.
First, you can supply the --repository argument on the command line.
If no --repository argument is specified, and the current directory is
within a clone of a project hosted on github, then the name of the repository
is detected automatically.  In order for this auto-detection to work,
the remote named "origin" must point to github.
""")

		name = match.group(1)
	return name

def remove_username(repository):
	"""Return the name of the repository, without the username.
Effectively a no-op if the repo name is not of the form username/project."""
	nameparts = repository.split('/', 1)
	if len(nameparts) == 1:
		return nameparts[0]
	else:
		return nameparts[1]

# Repository-related commands.
def cmd_repo_create(client, args):
	"""Create a new repository."""

	def validate_description(text):
		if len(text) == 0:
			print 'Description may not be empty.  Try again.'
			return False
		return True

	def validate_name(text):
		if len(text) == 0:
			print 'Name may not be empty.  Try again.'
			return False
		if any(char for char in text if char.isspace()):
			print 'Name may not contain spaces.  Try again.'
			return False
		# What other characters don't belong in the name?
		return True

	def validate_homepage(text):
		# This is a lame excuse for validation.
		if len(text) == 0:
			print 'Home page may not be empty.  Try again.'
			return False
		return True

	name = read_user_input('Repository name', validate_name)
	homepage = read_user_input('Homepage', validate_homepage)
	description = read_user_input('Description', validate_description)
	print client.repos.create(name, description, homepage)

def cmd_repo_fork(client, args):
	"""Fork a repository."""
	print client.repositorys.fork(args.repository)

def cmd_repo_list(client, args):
	"""Command to list the repos for a given user."""
	repos = client.repos.list(args.user)
	print '%s has the following repositories:' % args.user
	print 'Name - Description'
	for repo in repos:
		print '%s - %s' % (repo.name, repo.description)

# Commands for managing collaborators.
def cmd_collab_add(client, args):
	"""Add a collaborator to a repo."""
	repository = get_repository_name(args.repository)
	repository = remove_username(repository)
	print client.repos.add_collaborator(repository, args.user)

def cmd_collab_remove(client, args):
	"""Remove a collaborator from a repo."""
	repository = get_repository_name(args.repository)
	repository = remove_username(repository)
	print client.repos.remove_collaborator(repository, args.user)

def cmd_collab_list(client, args):
	"""List a repository's collaborators."""
	repository = get_repository_name(args.repository)
	collaborators = client.repos.list_collaborators(repository)
	if not collaborators:
		print 'There are no collaborators for %s.' % repository
	else:
		print 'The following people are collaborating on %s:' % \
			repository
		for collaborator in collaborators:
			print collaborator

# Option parsing.
def make_argument_parser():
	parser = argparse.ArgumentParser()
	subparsers = parser.add_subparsers(title='Subcommands')
	collab = subparsers.add_parser('collab', help='Manage collaborators.')
	repo = subparsers.add_parser('repo', help='Manage and query repositories.')
	subparsers = collab.add_subparsers(title='Collaborator-related Subcommands')
	collab_list = subparsers.add_parser('list', help='List collaborators for a given repository.')
	collab_list.set_defaults(func=cmd_collab_list)
	collab_list.add_argument('--repository', help='Name of the repository.')
	collab_add = subparsers.add_parser('add', help='Add a collaborator to a repository.')
	collab_add.set_defaults(func=cmd_collab_add)
	collab_add.add_argument('user', help='Name of the user.')
	collab_add.add_argument('--repository', help='Name of the repository.')
	collab_remove = subparsers.add_parser('remove', help='Remove a collaborator from a repository.')
	collab_remove.set_defaults(func=cmd_collab_remove)
	collab_remove.add_argument('user', help='Name of the user.')
	collab_remove.add_argument('--repository', help='Name of the repository.')
	subparsers = repo.add_subparsers(title='Repository-related Subcommands')
	repo_list = subparsers.add_parser('list', help='List repositories belonging to a given user.')
	repo_list.set_defaults(func=cmd_repo_list)
	repo_list.add_argument('user')
	repo_create = subparsers.add_parser('create', help='Create a new repository.')
	repo_create.set_defaults(func=cmd_repo_create)
	repo_fork = subparsers.add_parser('fork', help='Fork an existing repository.')
	repo_fork.set_defaults(func=cmd_repo_fork)
	repo_fork.add_argument('repository', help='Name of the repository, in the form USERNAME/REPONAME')
	return parser

def main():
	"""The main function."""
	username, token = get_username_and_token()
	client = github2.client.Github(username, token)
	parser = make_argument_parser()
	args = parser.parse_args()
 	args.func(client, args)

if __name__ == '__main__':
	main()
